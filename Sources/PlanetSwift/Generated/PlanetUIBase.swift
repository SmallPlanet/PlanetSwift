
//
// Autogenerated by gaxb at 04:37:59 PM on 06/10/20
//

import Foundation
import AEXML

//private let xmlCache = NSCache<NSString, AnyObject>()

open class PlanetUI {

	open class func readFromFile(_ filePath: String, prepare: Bool = true) -> GaxbElement? {
		do {
			let xmlString = try String(contentsOfFile: filePath, encoding: .utf8)
			return PlanetUI.readFromString(xmlString, prepare: prepare)
		} catch {
			return nil
		}
	}

	open class func readFromString(_ string: String, prepare: Bool = true) -> GaxbElement? {

		/*
		if let cachedElement = xmlCache.object(forKey: string as NSString) as? GaxbElement {
			let copiedCache = cachedElement.copy()
			if prepare {
				copiedCache.visit() { $0.gaxbPrepare() }
			}
			return copiedCache
		}*/

		if let xmlData = PlanetUI.processExpressions(string).data(using: .utf8, allowLossyConversion: false) {
			do {
		        var options = AEXMLOptions()
		        options.parserSettings.shouldProcessNamespaces = true
				let xmlDoc = try AEXMLDocument(xml: xmlData, options: options)
				if let parsedElement = PlanetUI.parseElement(xmlDoc.root) {
                    //let copiedElement = parsedElement.copy()
                    //xmlCache.setObject(copiedElement, forKey: string as NSString)
					if prepare {
						parsedElement.visit() { $0.gaxbPrepare() }
					}
					return parsedElement
				}
			} catch {
				return nil
			}
		}
		return nil
	}


	open class func namespaceForElement(_ element: AEXMLElement) -> String {
		if let namespaceURI = element.namespaceURI {
			return NSString(string: namespaceURI).lastPathComponent
		}
		return "PlanetUI"
	}

	open class func parseElement(_ element: AEXMLElement) -> GaxbElement? {
		guard let entity = GaxbFactory.element(namespaceForElement(element), name:element.name) else { return nil }
		if let styleId = element.attributes["styleId"],
			let styleElement = Object.styleForId(styleId) {
			_ = styleElement.imprintAttributes(entity)
		}
        // Note: the ordering of the attributes are not gauranteed, so check if externalClass exists first
        // and set it if it does, so the external class can have access to all of the attributes
        for (attribute, value) in element.attributes {
            if attribute == "externalClass" {
                entity.setAttribute(value, key: attribute)
                break
            }
        }
        
		for (attribute, value) in element.attributes {
            if attribute != "externalClass" {
                entity.setAttribute(value, key: attribute)
            }
		}
		
		for child in element.children {
			if let subEntity = PlanetUI.parseElement(child) {
				entity.setElement(subEntity, key: child.name)
			}
		}
		return entity
	}

	public enum ButtonType: String {
		case custom
		case system
		case detailDisclosure
		case infoLight
		case infoDark
		case contactAdd
	}

	public enum LineBreakMode: String {
		case wordWrapping
		case charWrapping
		case clipping
		case truncatingHead
		case truncatingTail
		case truncatingMiddle
	}

	public enum TextFieldViewMode: String {
		case never
		case whileEditing
		case unlessEditing
		case always
	}

	public enum ReturnKeyType: String {
		case Default
		case go
		case google
		case join
		case next
		case route
		case search
		case send
		case yahoo
		case done
		case emergencyCall
	}

	public enum TextAutocorrectionType: String {
		case Default
		case no
		case yes
	}

	public enum TextAutocapitalizationType: String {
		case none
		case words
		case sentences
		case allCharacters
	}

	public enum StackViewDistribution: String {
		case fill
		case fillEqually
		case fillProportionally
		case equalSpacing
		case equalCentering
	}

	public enum StackViewAlignment: String {
		case fill
		case leading
		case fistBaseline
		case center
		case trailing
		case bottom
		case top
		case lastBaseline
	}

	public enum ActivityIndicatorViewStyle: String {
		case whiteLarge
		case white
		case gray
	}

	public enum LayoutAttribute: String {
		case left
		case right
		case top
		case bottom
		case leading
		case trailing
		case width
		case height
		case centerX
		case centerY
		case baseline
		case firstBaseline
		case lastBaseline
		case notAnAttribute
	}

	public enum ContentMode: String {
		case scaleToFill
		case scaleAspectFit
		case scaleAspectFill
		case redraw
		case center
		case top
		case bottom
		case left
		case right
		case topLeft
		case topRight
		case bottomLeft
		case bottomRight
	}

	public enum TextSpellCheckingType: String {
		case Default
		case no
		case yes
	}

	public enum LayoutConstraintAxis: String {
		case horizontal
		case vertical
	}

	public enum AccessibilityTraits: String {
		case none
		case button
		case link
		case searchField
		case image
		case selected
		case playsSound
		case keyboardKey
		case staticText
		case summaryElement
		case notEnabled
		case updatesFrequently
		case startsMediaSession
		case adjustable
		case allowsDirectInteraction
		case causesPageTurn
		case header
	}

	public enum BlurEffect: String {
		case extraLight
		case light
		case dark
	}

	public enum TextAlignment: String {
		case left
		case center
		case right
		case justified
		case natural
	}

	public enum DatePickerMode: String {
		case time
		case date
		case dateAndTime
		case countDownTimer
	}

	public enum LayoutRelation: String {
		case lessThanOrEqual
		case equal
		case greaterThanOrEqual
	}

	public enum KeyboardType: String {
		case Default
		case ASCIICapable
		case numbersAndPunctuation
		case URL
		case numberPad
		case phonePad
		case namePhonePad
		case emailAddress
		case decimalPad
		case twitter
		case webSearch
	}

	public enum TextBorderStyle: String {
		case none
		case line
		case bezel
		case roundedRect
	}

	public enum LayoutRuleSet: String {
		case none
		case fillSuperview
		case equalSize
		case equalCenter
		case square
	}

}

@objc(PlanetUIGaxbFactory) public class PlanetUIGaxbFactory : GaxbFactory {
	public override func classWithName(_ name : String) -> GaxbElement? {
		switch name {
		case "View":
			return View()
		case "Scene":
			return Scene()
		case "TextView":
			return TextView()
		case "ImageView":
			return ImageView()
		case "DatePicker":
			return DatePicker()
		case "PageControl":
			return PageControl()
		case "Controller":
			return Controller()
		case "ActivityIndicatorView":
			return ActivityIndicatorView()
		case "StackView":
			return StackView()
		case "Switch":
			return Switch()
		case "PinchGestureRecognizer":
			return PinchGestureRecognizer()
		case "Object":
			return Object()
		case "CollectionView":
			return CollectionView()
		case "VisualEffectView":
			return VisualEffectView()
		case "SegmentedControl":
			return SegmentedControl()
		case "Constraint":
			return Constraint()
		case "GestureRecognizer":
			return GestureRecognizer()
		case "TextField":
			return TextField()
		case "NetworkImageView":
			return NetworkImageView()
		case "Label":
			return Label()
		case "Button":
			return Button()
		case "Notification":
			return Notification()
		case "Code":
			return Code()
		case "Control":
			return Control()
		case "PanGestureRecognizer":
			return PanGestureRecognizer()
		case "WebView":
			return WebView()
		case "PickerView":
			return PickerView()
		case "ScrollView":
			return ScrollView()
		default:
			return nil
		}
	}
}

public extension GaxbElement {
    var asView: View? { return self as? View }
    var asScene: Scene? { return self as? Scene }
    var asTextView: TextView? { return self as? TextView }
    var asImageView: ImageView? { return self as? ImageView }
    var asDatePicker: DatePicker? { return self as? DatePicker }
    var asPageControl: PageControl? { return self as? PageControl }
    var asController: Controller? { return self as? Controller }
    var asActivityIndicatorView: ActivityIndicatorView? { return self as? ActivityIndicatorView }
    var asStackView: StackView? { return self as? StackView }
    var asSwitch: Switch? { return self as? Switch }
    var asPinchGestureRecognizer: PinchGestureRecognizer? { return self as? PinchGestureRecognizer }
    var asObject: Object? { return self as? Object }
    var asCollectionView: CollectionView? { return self as? CollectionView }
    var asVisualEffectView: VisualEffectView? { return self as? VisualEffectView }
    var asSegmentedControl: SegmentedControl? { return self as? SegmentedControl }
    var asConstraint: Constraint? { return self as? Constraint }
    var asGestureRecognizer: GestureRecognizer? { return self as? GestureRecognizer }
    var asTextField: TextField? { return self as? TextField }
    var asNetworkImageView: NetworkImageView? { return self as? NetworkImageView }
    var asLabel: Label? { return self as? Label }
    var asButton: Button? { return self as? Button }
    var asNotification: Notification? { return self as? Notification }
    var asCode: Code? { return self as? Code }
    var asControl: Control? { return self as? Control }
    var asPanGestureRecognizer: PanGestureRecognizer? { return self as? PanGestureRecognizer }
    var asWebView: WebView? { return self as? WebView }
    var asPickerView: PickerView? { return self as? PickerView }
    var asScrollView: ScrollView? { return self as? ScrollView }
}
