//
// Autogenerated by gaxb at 12:23:33 AM on 06/11/20
//

// swiftlint:disable superfluous_disable_command
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable identifier_name
// swiftlint:disable force_cast
// swiftlint:disable type_body_length
// swiftlint:disable function_body_length
// swiftlint:disable line_length
// swiftlint:disable file_length

import Foundation
import AEXML

//private let xmlCache = NSCache<NSString, AnyObject>()

open class PlanetUI {

	open class func readFromFile(_ filePath: String, prepare: Bool = true) -> GaxbElement? {
		do {
			let xmlString = try String(contentsOfFile: filePath, encoding: .utf8)
			return PlanetUI.readFromString(xmlString, prepare: prepare)
		} catch {
			return nil
		}
	}

	open class func readFromString(_ string: String, prepare: Bool = true) -> GaxbElement? {

		/*
		if let cachedElement = xmlCache.object(forKey: string as NSString) as? GaxbElement {
			let copiedCache = cachedElement.copy()
			if prepare {
				copiedCache.visit() { $0.gaxbPrepare() }
			}
			return copiedCache
		}*/

		if let xmlData = PlanetUI.processExpressions(string).data(using: .utf8, allowLossyConversion: false) {
			do {
		        var options = AEXMLOptions()
		        options.parserSettings.shouldProcessNamespaces = true
				let xmlDoc = try AEXMLDocument(xml: xmlData, options: options)
				if let parsedElement = PlanetUI.parseElement(xmlDoc.root) {
                    //let copiedElement = parsedElement.copy()
                    //xmlCache.setObject(copiedElement, forKey: string as NSString)
					if prepare {
						parsedElement.visit { $0.gaxbPrepare() }
					}
					return parsedElement
				}
			} catch {
				return nil
			}
		}
		return nil
	}

	open class func namespaceForElement(_ element: AEXMLElement) -> String {
		if let namespaceURI = element.namespaceURI {
			return NSString(string: namespaceURI).lastPathComponent
		}
		return "PlanetUI"
	}

	open class func parseElement(_ element: AEXMLElement) -> GaxbElement? {
		guard let entity = GaxbFactory.element(namespaceForElement(element), name: element.name) else { return nil }
		if let styleId = element.attributes["styleId"],
			let styleElement = Object.styleForId(styleId) {
			_ = styleElement.imprintAttributes(entity)
		}
        // Note: the ordering of the attributes are not gauranteed, so check if externalClass exists first
        // and set it if it does, so the external class can have access to all of the attributes
        for (attribute, value) in element.attributes where attribute == "externalClass" {
            entity.setAttribute(value, key: attribute)
            break
        }

		for (attribute, value) in element.attributes where attribute != "externalClass" {
            entity.setAttribute(value, key: attribute)
		}

		for child in element.children {
			if let subEntity = PlanetUI.parseElement(child) {
				entity.setElement(subEntity, key: child.name)
			}
		}
		return entity
	}

	public enum TextBorderStyle: String {
		case none
		case line
		case bezel
		case roundedRect
	}

	public enum AccessibilityTraits: String {
		case none
		case button
		case link
		case searchField
		case image
		case selected
		case playsSound
		case keyboardKey
		case staticText
		case summaryElement
		case notEnabled
		case updatesFrequently
		case startsMediaSession
		case adjustable
		case allowsDirectInteraction
		case causesPageTurn
		case header
	}

	public enum ReturnKeyType: String {
		case `default`
		case go
		case google
		case join
		case next
		case route
		case search
		case send
		case yahoo
		case done
		case emergencyCall
	}

	public enum StackViewAlignment: String {
		case fill
		case leading
		case fistBaseline
		case center
		case trailing
		case bottom
		case top
		case lastBaseline
	}

	public enum TextAutocapitalizationType: String {
		case none
		case words
		case sentences
		case allCharacters
	}

	public enum DatePickerMode: String {
		case time
		case date
		case dateAndTime
		case countDownTimer
	}

	public enum TextSpellCheckingType: String {
		case `default`
		case no
		case yes
	}

	public enum TextAlignment: String {
		case left
		case center
		case right
		case justified
		case natural
	}

	public enum LayoutConstraintAxis: String {
		case horizontal
		case vertical
	}

	public enum KeyboardType: String {
		case `default`
		case asciiCapable
		case numbersAndPunctuation
		case URL
		case numberPad
		case phonePad
		case namePhonePad
		case emailAddress
		case decimalPad
		case twitter
		case webSearch
	}

	public enum ContentMode: String {
		case scaleToFill
		case scaleAspectFit
		case scaleAspectFill
		case redraw
		case center
		case top
		case bottom
		case left
		case right
		case topLeft
		case topRight
		case bottomLeft
		case bottomRight
	}

	public enum StackViewDistribution: String {
		case fill
		case fillEqually
		case fillProportionally
		case equalSpacing
		case equalCentering
	}

	public enum BlurEffect: String {
		case extraLight
		case light
		case dark
	}

	public enum ActivityIndicatorViewStyle: String {
		case whiteLarge
		case white
		case gray
	}

	public enum LineBreakMode: String {
		case wordWrapping
		case charWrapping
		case clipping
		case truncatingHead
		case truncatingTail
		case truncatingMiddle
	}

	public enum LayoutRuleSet: String {
		case none
		case fillSuperview
		case equalSize
		case equalCenter
		case square
	}

	public enum LayoutRelation: String {
		case lessThanOrEqual
		case equal
		case greaterThanOrEqual
	}

	public enum ButtonType: String {
		case custom
		case system
		case detailDisclosure
		case infoLight
		case infoDark
		case contactAdd
	}

	public enum TextFieldViewMode: String {
		case never
		case whileEditing
		case unlessEditing
		case always
	}

	public enum LayoutAttribute: String {
		case left
		case right
		case top
		case bottom
		case leading
		case trailing
		case width
		case height
		case centerX
		case centerY
		case baseline
		case firstBaseline
		case lastBaseline
		case notAnAttribute
	}

	public enum TextAutocorrectionType: String {
		case `default`
		case no
		case yes
	}

}

@objc(PlanetUIGaxbFactory) public class PlanetUIGaxbFactory: GaxbFactory {
	public override func classWithName(_ name: String) -> GaxbElement? {
		switch name {
		case "Label":
			return Label()
		case "Button":
			return Button()
		case "PickerView":
			return PickerView()
		case "CollectionView":
			return CollectionView()
		case "Code":
			return Code()
		case "Constraint":
			return Constraint()
		case "TextField":
			return TextField()
		case "WebView":
			return WebView()
		case "SegmentedControl":
			return SegmentedControl()
		case "Scene":
			return Scene()
		case "NetworkImageView":
			return NetworkImageView()
		case "Switch":
			return Switch()
		case "ActivityIndicatorView":
			return ActivityIndicatorView()
		case "ScrollView":
			return ScrollView()
		case "Object":
			return Object()
		case "TextView":
			return TextView()
		case "ImageView":
			return ImageView()
		case "PageControl":
			return PageControl()
		case "View":
			return View()
		case "Slider":
			return Slider()
		case "DatePicker":
			return DatePicker()
		case "Controller":
			return Controller()
		case "GestureRecognizer":
			return GestureRecognizer()
		case "VisualEffectView":
			return VisualEffectView()
		case "Notification":
			return Notification()
		case "Control":
			return Control()
		case "PinchGestureRecognizer":
			return PinchGestureRecognizer()
		case "StackView":
			return StackView()
		case "PanGestureRecognizer":
			return PanGestureRecognizer()
		default:
			return nil
		}
	}
}

public extension GaxbElement {
    var asLabel: Label? { return self as? Label }
    var asButton: Button? { return self as? Button }
    var asPickerView: PickerView? { return self as? PickerView }
    var asCollectionView: CollectionView? { return self as? CollectionView }
    var asCode: Code? { return self as? Code }
    var asConstraint: Constraint? { return self as? Constraint }
    var asTextField: TextField? { return self as? TextField }
    var asWebView: WebView? { return self as? WebView }
    var asSegmentedControl: SegmentedControl? { return self as? SegmentedControl }
    var asScene: Scene? { return self as? Scene }
    var asNetworkImageView: NetworkImageView? { return self as? NetworkImageView }
    var asSwitch: Switch? { return self as? Switch }
    var asActivityIndicatorView: ActivityIndicatorView? { return self as? ActivityIndicatorView }
    var asScrollView: ScrollView? { return self as? ScrollView }
    var asObject: Object? { return self as? Object }
    var asTextView: TextView? { return self as? TextView }
    var asImageView: ImageView? { return self as? ImageView }
    var asPageControl: PageControl? { return self as? PageControl }
    var asView: View? { return self as? View }
    var asSlider: Slider? { return self as? Slider }
    var asDatePicker: DatePicker? { return self as? DatePicker }
    var asController: Controller? { return self as? Controller }
    var asGestureRecognizer: GestureRecognizer? { return self as? GestureRecognizer }
    var asVisualEffectView: VisualEffectView? { return self as? VisualEffectView }
    var asNotification: Notification? { return self as? Notification }
    var asControl: Control? { return self as? Control }
    var asPinchGestureRecognizer: PinchGestureRecognizer? { return self as? PinchGestureRecognizer }
    var asStackView: StackView? { return self as? StackView }
    var asPanGestureRecognizer: PanGestureRecognizer? { return self as? PanGestureRecognizer }
}
